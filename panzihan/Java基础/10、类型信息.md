# 类型信息

1. 运行时类型信息使得你可以在程序运行受发现和使用类型信息。它使你从只能在编译期执行面向类型的操作的禁锢中解脱出来，并且可以使用某些非常强大的程序。
2. Java是如何让我们在运行时识别对象和类的信息的。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时，已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。

### 1、Class对象

1. 类是程序的一部分，每个类都有一个Class对象。换言之，每当编写并且编译了一个新类，就会产生Class对象（更恰当地说，是被保存在一个同名的.class文件中）。为了生成这个类的对象，运行这个程序的Java虚拟机（JVM）将使用被称为“类加载器”的子系统。
2. 类加载器子系统实际可以包含一条类加载器链，但是只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是所谓的可信类，包括Java API类，它们通常是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器。
3. 所有的类都是在对其第一次使用时，动态加载到JVM中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。这个证明构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此使用new操作符创建类的新对象也会被当作对类的静态成员的引用。
4. Java程序在它开始运行之前并非被完全加载，其各部分是在必须的时才加载上去的。这一点与许多传统语言都不同。
5. 类加载器首先检查者类的Class对象是否已经加载。如果未加载，默认的类加载器就会根据类名找.class文件。
6. 一旦某个类的Class对象被载入内存，它就被用来创建者类的所有对象。

```java
public Student {}
pulbic class Test {
    public static void main(String[] args) {
        Student s = Class.forName("Student");//获取某个对象
        Class c = s.getClass();//获取Class对象
        c.getName();//获取名字
        c.getSimpleName();
        c.getCanonicalName();
        c.getSuperClass();//获取父类的Class对象
        c.getInterfaces();//获取接口对象集
        c.newInstance();//创建对象实例
    }
}
```

#### 1.1、类字面常量

1. Java还提供了另外一种方法来生成对Class对象的引用，即使用类字面常量。如`FancyToy.class`
2. 优点：更简单，而且安全，在编译的时候就会受到检查。

* 注意，有一点很有趣，当使用“.class”来创建对Class对象的引用的时，不会主动地初始化该Class对象。为了使用类而做的准备工作实际包含三个步骤：
  * 加载，这是由类加载器执行，该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个Class对象。
  * 链接，在链接的阶段见验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所用引用。
  * 初始化，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。
* 初始化有效地实现了尽可能的“惰性”，仅使用.class语法来获取对类的引用不会引发初始化。但是，为了产生Class引用，Class.forName（）立即就进行了初始化。
* 如果一个static final值是编译期常量，那么这个值不需要进行初始化就可以读取。但是，如果只是将一个域设置为static final的，还不足确保这种行为。

#### 1.2、泛化的Class引用