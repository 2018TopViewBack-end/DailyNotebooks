# 复用类

### 1、组合语法

### 2、继承语法

* 一个程序中含有多个类，也只有命令行所调用的那个类的main（）方法会被调用；

#### 2.1、初始化基类

1. Java会自动在导出类的构造器中插入对基类构造器的调用。
2. 构建过程是从基类“向外”扩散的，所以基类在导出类构造器可以访问它之前，就已经完成了初始化。
3. 如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字super显示地编写调用基类构造器的语句，并且配以适当的参数列表。
4. 调用基类构造器必须是你在导出类构造器中要做的第一件事。

### 3、代理

代理是继承和组合之间的中庸之道，因为我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该成员对象的所有方法（就像继承）。

我们使用代理时可以拥有更多的控制力，因为我们可以选择只提供在成员对象中的方法的某个子集。

### 4、结合使用组合和继承

编译器强制你去初始化基类，并且要求你要在构造器起始处就要这么做，但是它并不监督你必须将成员对象初始化，因此在这一点上你自己必须时刻注意。

#### 4.1、确保正确清理

无论try块是怎样的退出，保护区后的finally子句中的代码总是要被执行。

#### 4.2、名称屏蔽

Java SE5新增加了@Override注解，它并不是关键字，但是可以把它当作关键字使用。当你想要覆写某个方法时，可以选择添加这个注解，在你不留心重载而并非覆写了该方法时，编译器就会生成一条错误信息。

### 5、在组合与继承之间选择

1. 组合和继承都允许在新的类中放置子对象，组合是显示地这样这样做，而继承则是隐式地做。
2. 在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入的对象的接口。为取得此效果，需要在新类中嵌入一个现有类的private对象。
3. 一般情况下应该使得域成为private。

### 6、protected关键字

它指明“就类用户而言，这是private的，但对于任何继承于此类的导出类或者其他任何位于同一个包内的类来说，它却是可以访问的”。

### 7、向上转型

1. 在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。这就是为什么编译器在“未曾明确表示转型”或“未曾指定特殊标记”的情况下，任然允许向上转型的原因。
2. 一个最清晰的判断（使用组合还是继承）的办法就是问一问自己是否需要从新类向基类进行向上转型。如果必须向上转型，则继承是必要的，但如果不需要，则应当好好考虑自己是否需要继承。

### 8、final关键字

对于基本类型，final使数值恒定不变；而对于对象引用，final使引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。

#### 8.1、空白final

1. 所谓空白final是指被声明为final但又未给顶初值的域。
2. 必须在域的定义处或者每个构造器中用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因。

#### 8.2、final参数

1. Java允许在参数列表中以声明的方式将参数指明未final。
2. 你可以读参数，但却无法修改参数。这一特性主要用来向匿名内部类传递数据。

#### 8.3、final方法

1. 使用final方法的原因
   1. 把方法锁定，以防任何继承类修改它的含义。这是出于设计考虑：想要确保在继承中使方法行为保持不变，并且不会被覆盖。
   2. 效率。
2. 类中所有的private方法都隐式地指定未是final的。

#### 8.4、final类

由于final类简直继承，所以final类中所有的方法都隐式指定未final，因为无法覆盖它们。在final类中可以给方法添加final修饰词，但这并不会增添任何意义。

### 9、初始化及类的加载

每个类的编译代码都存在于它自己的独立文件中。该文件只在需要使用程序代码时才会被加载。

### 小结

尽管面向对象编程对继承极力强调，但在开始一个设计时，一般有限选择使用组合（或者可能是代理），只在确实必要时才使用继承。